<!DOCTYPE html>
<html>
	<head>
		
			<title>Getting Started</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../_static/icon.png"/>
		<link rel="stylesheet" href="../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../_components/jquery/jquery.min.js"></script>
		<script src="../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		
		<script src="../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
		//]]>
		</script>
	</head>

	<body>
		<header><label for="toggle">☰</label>  › <a class="link" href="../../index.html">Project</a> › <a class="link" href="../index.html">Guides</a></header>
		
		<main>
			
	<h1>Getting Started</h1>
	
	<p>This guide explains how to use <code>thread-local</code> for &quot;global state&quot;.</p>
<section id="installation"><h2>Installation</h2>
<p>Add the gem to your project:</p>
<pre><code class="language-bash">$ bundle add thread-local
</code></pre>
</section><section id="per-class-thread-local-instance"><h2>Per-Class Thread Local Instance</h2>
<p>In your own class, e.g. <code>FileCache</code>:</p>
<pre><code class="language-ruby">class FileCache
	extend Thread::Local
	
	def initialize
		@cache = {}
	end
	
	def load_file(path)
		@cache.fetch(path) do
			@cache[path] = File.read(path)
		end
	end
end
</code></pre>
<p>Now, instead of instantiating your cache <code>CACHE = FileCache.new</code>, use <code>FileCache.instance</code>. It will return a thread-local instance.</p>
<pre><code class="language-ruby">Thread.new do
	FileCache.instance
	# =&gt; #&lt;FileCache:0x000055a14ec6be80&gt;
end

Thread.new do
	FileCache.instance
	# =&gt; #&lt;FileCache:0x000055a14ec597d0&gt;
end
</code></pre>
<p>You may think, what is the point of a file cache which is not shared across all threads? And yes, you would be right. Within a single thread (i.e. application instance), files will be cached, but not between threads. The benefit of this approach is that it is the same level of isolation irrespective of the server being multi-process or multi-thread, and allows the server to manage application state on a per-thread basis (e.g. for rolling restarts/reloads).</p>
</section><section id="non-global-state"><h3>Non-global State</h3>
<p>This wrapper is designed for state which would otherwise be global. It is not designed to be used to replace instance variables which would otherwise need to be thread-safe. For that, you should prefer things like <a href="https://www.rubydoc.info/gems/concurrent-ruby/Concurrent/Map"><code>Concurrent::Map</code></a>.</p>
</section><section id="extending-locals"><h3>Extending Locals</h3>
<p>In some cases, you might want to extend a thread local, e.g. change the way it's initialized or modify the object after it was initialized on demand. You can do this at the process-level using a module:</p>
<pre><code class="language-ruby">module WarmCache
	def local
		instance = super
		
		instance.load_file(&quot;/dev/random&quot;)
		
		return instance
	end
end

FileCache.extend(WarmCache)
</code></pre>
<p>When a file cache is created, it will also execute the code in <code>WarmCache#local</code>.</p>
</section>
				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>